# 문제 분해 커맨드 (Problem Decomposition Command)

당신은 복잡한 기능을 체계적으로 분해하여 실행 가능한 계획으로 만드는 전문가입니다.

## 구현할 기능

$ARGUMENTS

---

## 수행할 작업

위에서 제공된 기능을 아래 원칙과 절차에 따라 체계적으로 분해하여 실행 계획을 생성하세요.

### 분해 원칙

1. **MECE (Mutually Exclusive, Collectively Exhaustive)**
   - 상호 배타적: 각 하위 작업이 중복되지 않음
   - 전체 포괄적: 모든 하위 작업을 합치면 전체를 커버

2. **단일 책임 (Single Responsibility)**
   - 각 작업은 하나의 명확한 목표만 가짐
   - "~하고 ~한다" 형태의 복합 작업 금지

3. **검증 가능성 (Verifiable)**
   - 각 작업에 명확한 완료 기준 포함
   - "~가 동작한다", "~가 표시된다" 등 측정 가능한 기준

4. **적절한 크기 (Right-sized)**
   - 권장: 1-4시간 내 완료 가능한 크기
   - L 크기(4시간 이상) 작업은 더 분해 필요

5. **의존성 명확화 (Dependency Clarity)**
   - 각 작업의 선행 조건을 명시
   - 병렬 실행 가능 여부를 식별
   - 블로킹 작업과 비블로킹 작업 구분

### 분해 절차

1. **핵심 목표 파악**: 기능의 최종 목표가 무엇인가?
2. **주요 구성 요소 식별**: 3-5개의 큰 덩어리로 나누기
3. **세부 분해**: 각 구성 요소를 실행 가능한 작업으로 분해
4. **의존성 파악**: 작업 간 선후 관계 정의
5. **실행 순서 결정**: 의존성 기반 순서 배치

### 분해 전략

상황에 따라 적합한 전략을 선택:
- **기능적 분해**: 독립적인 기능/모듈 단위로 분리
- **계층적 분해**: 아키텍처 계층별 분리 (DB → API → 로직 → UI)
- **시간적 분해**: 실행 순서/단계별 분리 (설계 → 구현 → 테스트)
- **하이브리드**: 위 전략들을 조합 (권장)

### 의존성 분석

작업 간 의존성을 분석하여 효율적인 실행 순서를 결정합니다.

#### 의존성 유형

| 유형 | 기호 | 설명 | 예시 |
|------|------|------|------|
| **순차 (Sequential)** | `→` | 반드시 선행 작업 완료 후 시작 | DB 스키마 → API 구현 |
| **병렬 (Parallel)** | `∥` | 동시 진행 가능 | 프론트엔드 ∥ 백엔드 |
| **선택적 (Optional)** | `?→` | 있으면 좋지만 필수 아님 | 캐싱 ?→ 최적화 |
| **블로킹 (Blocking)** | `⊗` | 완료 전까지 다음 단계 전체 차단 | 인증 ⊗ 모든 API |

#### 병렬 처리 판단 기준

작업이 병렬 처리 가능한 경우:
- [ ] 공유 리소스(DB 테이블, 파일, 상태)를 동시에 수정하지 않음
- [ ] 서로의 출력물을 입력으로 사용하지 않음
- [ ] 독립적인 모듈/컴포넌트에서 작업
- [ ] 동일 파일을 편집하지 않음

병렬 처리 불가능한 경우:
- ⚠️ 동일 데이터베이스 스키마 변경
- ⚠️ 공유 상태(Context, Store) 구조 변경
- ⚠️ 공통 타입 정의 수정
- ⚠️ 선행 작업의 API/인터페이스에 의존

#### 크리티컬 패스 (Critical Path)

가장 오래 걸리는 의존성 체인을 식별하여 우선 처리:

```
크리티컬 패스 예시:
[DB 스키마] → [API 구현] → [프론트엔드 연동] → [테스트]
     M            M              M               S
                    총 소요: M+M+M+S = 크리티컬 패스
```

#### 의존성 그래프 표기

```
작업 A ─┬─→ 작업 C ─→ 작업 E
        │              ↑
작업 B ─┘              │
        ├─→ 작업 D ────┘

범례: ─→ 순차, ─┬─ 분기(병렬 시작), ─┘ 합류(병렬 종료)
```

### 멀티에이전트 실행 전략

분해된 작업들을 효율적으로 실행하기 위한 에이전트 할당 전략입니다.

#### 에이전트 실행 모드

| 모드 | 설명 | 사용 시점 |
|------|------|----------|
| **🔵 병렬 에이전트** | 여러 Task 에이전트를 동시에 실행 | 독립적인 작업들을 동시 처리 |
| **🔴 순차 에이전트** | 하나의 에이전트가 순서대로 실행 | 의존성이 있는 작업 체인 |
| **🟡 백그라운드 에이전트** | 백그라운드에서 실행 후 결과 확인 | 빌드, 테스트 등 장시간 작업 |

#### 병렬 에이전트 실행 조건

다음 조건을 **모두** 만족할 때 병렬 에이전트로 실행:
- [ ] 작업들이 서로 다른 파일/디렉토리에서 작업
- [ ] 공유 상태나 타입 정의를 동시에 수정하지 않음
- [ ] 한 작업의 출력이 다른 작업의 입력이 아님
- [ ] 동일한 외부 리소스(API, DB)에 동시 쓰기 없음

#### 순차 에이전트 실행 필수 조건

다음 중 **하나라도** 해당되면 순차 실행:
- ⚠️ 타입 정의(`types/`) 파일 수정 후 해당 타입 사용
- ⚠️ API/인터페이스 정의 후 구현
- ⚠️ 공통 유틸리티 수정 후 사용처 업데이트
- ⚠️ 스키마/모델 변경 후 관련 로직 수정

#### 에이전트 실행 예시

**병렬 실행 (독립 작업):**
```
// 동시에 여러 Task 에이전트 실행
Task(에이전트1): "Header 컴포넌트 구현"
Task(에이전트2): "Footer 컴포넌트 구현"
Task(에이전트3): "Sidebar 컴포넌트 구현"
→ 3개 에이전트가 동시에 작업, 모두 완료 후 다음 단계
```

**순차 실행 (의존 작업):**
```
// 순서대로 실행
Task(에이전트1): "City 타입 정의" → 완료 대기
Task(에이전트2): "City API 구현" → 완료 대기
Task(에이전트3): "CityCard 컴포넌트 구현"
→ 각 단계 완료 후 다음 에이전트 실행
```

**혼합 실행:**
```
[Phase 1] 순차: 타입 정의 완료
    ↓
[Phase 2] 병렬: API ∥ 컴포넌트 ∥ 훅 (동시 진행)
    ↓
[Phase 3] 순차: 통합 및 테스트
```

---

## 출력 형식

아래 형식으로 분해 결과를 출력하세요:

```markdown
## [기능명] 구현 계획

### 개요
- **목표**: (한 줄 요약)
- **예상 작업 수**: N개
- **주요 구성요소**: (쉼표로 구분)
- **예상 난이도**: 낮음 / 중간 / 높음

### 가정 사항
- 가정 1: [불확실한 부분에 대한 가정]
- 가정 2: [...]

### Phase 1: [단계명]

- [ ] **1.1 [작업명]**
  - 설명: (무엇을 하는가)
  - 완료 기준: (어떻게 완료를 확인하는가)
  - 의존성: 없음 / 작업 번호
  - 실행 유형: 🔵 병렬 가능 / 🔴 순차 필수 / ⊗ 블로킹
  - 예상 소요: S/M/L

#### 🔵 병렬 그룹 A (동시 진행 가능)
- [ ] 1.2 [작업명] - 독립적 작업
- [ ] 1.3 [작업명] - 독립적 작업

### Phase 2: [단계명]
...

### 의존성 요약

#### 실행 흐름도
```
[Phase 1] ──→ [Phase 2] ──→ [Phase 3]
    │
    ├─ 1.1 ─→ 2.1 ─→ 3.1
    │         ↑
    └─ 1.2 ───┘ (병렬)
```

#### 병렬 처리 기회
| 그룹 | 작업들 | 예상 단축 시간 |
|------|--------|---------------|
| A | 1.2, 1.3 | M → S (동시 진행) |
| B | 2.1, 2.2 | M → S (동시 진행) |

#### 크리티컬 패스
`1.1 → 2.1 → 3.1` (총 예상: M+M+S)

⚠️ **블로킹 작업 주의**: 작업 X.X는 완료 전까지 다음 Phase 진행 불가

### 멀티에이전트 실행 계획

#### 실행 순서

| 단계 | 실행 모드 | 작업 | 에이전트 수 |
|------|----------|------|------------|
| 1 | 🔴 순차 | 1.1 타입 정의 | 1 |
| 2 | 🔵 병렬 | 1.2, 1.3, 1.4 | 3 |
| 3 | 🔴 순차 | 2.1 통합 | 1 |
| 4 | 🟡 백그라운드 | 3.1 테스트 실행 | 1 |

#### 에이전트 실행 명령

**Step 1: 순차 실행**
```
Task: "1.1 [작업명] 구현"
→ 완료 대기 후 Step 2 진행
```

**Step 2: 병렬 실행** ⚡
```
동시 실행:
- Task(Agent A): "1.2 [작업명] 구현"
- Task(Agent B): "1.3 [작업명] 구현"
- Task(Agent C): "1.4 [작업명] 구현"
→ 모든 에이전트 완료 대기 후 Step 3 진행
```

**Step 3: 순차 실행**
```
Task: "2.1 [작업명] 통합"
→ 완료 대기
```

#### 주의사항
- 🔴 순차 작업은 반드시 이전 작업 완료 확인 후 시작
- 🔵 병렬 작업은 모든 에이전트가 완료될 때까지 다음 단계 진행 금지
- ⚠️ 파일 충돌 가능성이 있으면 순차로 변경

### 검증 체크리스트
- [ ] 전체 기능이 정상 동작하는가?
- [ ] 엣지 케이스가 처리되는가?
- [ ] 에러 처리가 적절한가?
- [ ] 병렬 작업 간 충돌이 없는가?
- [ ] 의존성 순서가 올바른가?

### 대안/옵션 (해당 시)
**옵션 A**: [접근법 1]
- 장점: ...
- 단점: ...
```

---

## 추가 지시사항

1. **모호한 입력**: 기능 설명이 모호하면 먼저 명확화 질문을 합니다
2. **가정 명시**: 불확실한 부분은 "가정:" 으로 명시합니다
3. **대안 제시**: 여러 접근법이 있으면 옵션과 장단점을 제시합니다
4. **위험 요소**: 복잡하거나 위험한 작업은 ⚠️로 표시합니다
5. **프로젝트 컨텍스트**: 현재 프로젝트의 기술 스택(Next.js 16, TypeScript, Tailwind CSS, shadcn/ui)을 고려하여 분해합니다
6. **병렬화 최적화**: 병렬 처리 가능한 작업을 그룹화하여 전체 소요 시간 최소화
7. **의존성 충돌 방지**: 동일 파일/리소스 수정 작업은 순차 실행으로 표시
8. **크리티컬 패스 명시**: 전체 일정에 영향을 주는 핵심 경로를 식별
9. **멀티에이전트 실행 계획 필수**: 모든 분해 결과에 "멀티에이전트 실행 계획" 섹션 포함
10. **에이전트 모드 명시**: 각 작업/그룹에 🔵 병렬 / 🔴 순차 / 🟡 백그라운드 모드 표시
11. **실행 명령 구체화**: Task 에이전트 호출 형태로 실행 명령 작성

### 작업 크기 기준

| 크기 | 설명 | 예시 |
|------|------|------|
| **S** | 1시간 이내 | 단일 컴포넌트, 단순 함수 |
| **M** | 1-4시간 | API 엔드포인트, 복합 컴포넌트 |
| **L** | 4시간 이상 | 더 분해 필요 |

---

지금 바로 위에서 제공된 기능을 분해하여 실행 계획을 생성하세요.
